\documentclass[hyperref={colorlinks,citecolor=blue,linkcolor=blue,urlcolor=blue}]{beamer}
\usepackage{xcolor}
\usepackage{pgfpages}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsmath,amssymb}


\mode<presentation>
{
  \usetheme{Madrid}       % or try default, Darmstadt, Warsaw, ...
  \usecolortheme{beaver} % or try albatross, beaver, crane, ...
  \usefonttheme{default}    % or try default, structurebold, ...
  \setbeamertemplate{navigation symbols}{}
  \setbeamertemplate{caption}[numbered]
} 



\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\usepackage{listings}
\lstdefinestyle{mystyle}{
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\small,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\pgfpagesuselayout{resize to}[%
  physical paper width=8in, physical paper height=6in]

\title[IbraFSG 3: List Comprehensions]{IbraFSG\texttrademark{} 3 - Week 7; List Comprehensions}


\author{Ibrahim Chehab}
\institute{UTM RGASC}
\date{\today}

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\begin{frame}{Table of Contents}
  \tableofcontents
\end{frame}

\section{Introduction}

\subsection{Welcome back to IbraFSGs\texttrademark{}}
\begin{frame}
  \frametitle{Welcome back to IbraFSGs\texttrademark{}}
  \begin{itemize}
  \item Welcome back to IbraFSGs\texttrademark{}! Hello to new people and welcome back to tenured members.
  \item This week we will be discussing \textit{list comprehensions}.
  \item List Comprehensions are a way to create lists in Python using very little code. They are a very powerful tool that you will use in the future (A2)
\end{itemize}

\end{frame}

\subsection{A Recap of the UltraSheet\texttrademark{}}
\begin{frame}{A Recap of the UltraSheet\texttrademark{}}
  \begin{itemize}
    \item An \textit<overlay specification>{UltraSheet\texttrademark{}} is a "cheat sheet" that you compile for yourself to review course materials 
    \item It acts like your own personalized textbook chapter
    \item It is a great way to review for tests and exams, and find gaps in your knowledge
    \item UltraSheets\texttrademark{} help with type 1 and 2 questions 
  \end{itemize}


\end{frame}

\subsection{Key Terms}
\begin{frame}{Key Terms}
  \begin{itemize}
    \item \textbf{List Comprehension:} A way to create lists in Python using very little code. 
    \item \textbf{Expression:} A piece of code that returns a value.
    \item \textbf{Iterable:} An object that can be iterated over.
    \end{itemize}
    ...Yeah that's about it for this week. 
    \textbf{Note:} Your UltraSheets\texttrademark{} should be filled with examples and explanations of these terms, and specifically how they relate to List Comprehensions.
\end{frame}

\section{List Comprehensions}

\subsection{A Trick to understanding list comprehensions}

\begin{frame}[fragile]
  \frametitle{A Trick to Understanding List Comprehensions}
    List Comprehensions may seem scary at first, but they are actually quite simple. The trick to understanding them is to relate them to MAT102:

  Example:
  
  \begin{columns}[T]
    \begin{column}{0.4\textwidth}
    \begin{align*}
        \{x^2 : x \in \{0, 1, 2, 3, 4, 5\}\}
    \end{align*}
    \end{column}
    \hfill
    \begin{column}{0.1\textwidth}
    \begin{center}
    \Large $\iff$
    \end{center}
    \end{column}
    \hfill
    \begin{column}{0.5\textwidth}
    \begin{lstlisting}[language=Python, style=mystyle]
[x**2 for x in range(6)]
    \end{lstlisting}
    \end{column}
    \end{columns}


    \textbf{Fun Fact:} You can include conditionals in list comprehensions, and items to be added if the condition is not met! Example:
    \begin{lstlisting}[language=Python, style=mystyle]
[x**2 for x in range(6) if x % 2 == 0 else x**3]
    \end{lstlisting}
    would return a list like this:
    \begin{lstlisting}[language=Python, style=mystyle]
[0, 1, 4, 27, 16, 125]
    \end{lstlisting}
\end{frame}

\section{Practice Problems}
\subsection{Practice Problem I: Loop2LstComp}
\begin{frame}[fragile]
  
  \frametitle{Practice Problem I: Loop2LstComp}

  Convert the following for loops to an equivalent list comprehension:
  \begin{lstlisting}[language=Python, style=mystyle]
# Q1: 
lst = []
for i in songs: # songs is an arbitrary list of Song objects; implementation is irrelevant for this question 
  lst.append(i.title)
# Q2:
filter = []
for song in songs:
    if song.is_liked():
        filter.append(song)
\end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Practice Problem I: Loop2LstComp (hard mode)}
  \begin{lstlisting}[language=Python, style=mystyle]
# Q3 (aka the end of all of you)
lst = []
for song in songs:
  if song.genre == "Rock":
    filter.append("Rock on!")
  elif song.genre == "Pop":
    filter.append("Pop on!")
  elif song.genre == "Love":
    filter.append("No Swifties Allowed")
  else:
    filter.append("euuuh, brother euuuh")
    \end{lstlisting}
\textit{Hint:} You can't use \texttt{elif} in a List Comprehension, but you can use \texttt{if} and \texttt{else}. How can we replicate the \texttt{elif} functionality using only \texttt{if} and \texttt{else}?\\
\textit{Hint 2:} Start by eliminating \texttt{elif} in the original problem
\end{frame}

\begin{frame}[fragile]
  \frametitle{Practice Problem II: CompOut}


\end{frame}


\subsection{Practice Problem II: Iterative to Recursive}

\begin{frame}[fragile]
  \frametitle{Practice Problem II: Iterative to Recursive}
  
  Convert the following iterative function to a recursive function:

  \begin{lstlisting}[language=Python, style=mystyle]
def ibranatchi_iterative(n: int) -> int:
  if n == 0:
    return 0
  elif n == 1:
    return 1
  elif n == 2:
    return 5

  sequence = [0, 1, 5]
  for i in range(3, n + 1):
    next_value = sequence[i - 1] * 2 * sequence[i - 2] - 5 * sequence[i - 3]
    sequence.append(next_value)

  return sequence[-1]
 
def ibranatchi_recursive(n: int) -> int:
  # TODO: Implement this recursively:

  \end{lstlisting}
\end{frame}
\subsection{Debrief: Space and Time Complexity}
\begin{frame}
  \frametitle{Debrief: Space and Time Complexity}
  Hash the following out in your groups:
  \begin{itemize}
    \item What is the time complexity of a list comprehension?
    \item What is the time complexity of the for-loop equivalent of a list comprehension?
\end{itemize}
\end{frame}

\section{Conclusion}
\subsection{A Final Challenge...}

\begin{frame}
  \frametitle{A final challenge...}
Recall from last week our challenge problem:

Sharon Goodwin delves into Python in her free time. She's trying to create a series of recursive functions that mutually recurse over each other to determine whether a positive integer is even or odd. Help her create these two functions.
\begin{center}
  \textbf{RESTRICTIONS:}
  \begin{itemize}
    \item You are \textbf{NOT} allowed to use \textbf{ANY} of Python's integer operations \textbf{EXCEPT} subtraction.
    \item You may \textbf{NOT} use \textbf{Modulo}.
    \item Each function must have \textbf{EXACTLY} one base-case.
    \item You \textbf{MUST} use mutual recursion.
    \item You \textbf{MAY NOT} use any helper methods.
  \end{itemize}  
\end{center}
\end{frame}
\begin{frame}[fragile]
  \frametitle{A final challenge\ldots}
  Continue solving this problem today: 
  \begin{lstlisting}[language=Python, style=mystyle]
def is_even(num: int) -> bool:
    """
    Method which uses mutual recursion to determine whether an integer is even or odd.
    """
    # TODO: Implement this method with a recursive call to is_odd


def is_odd(num: int) -> bool:
    """
    Method which uses mutual recursion to determine whether an integer is even or odd.
    """
      # TODO: Implement this method with a recursive call to is_even
    \end{lstlisting}    
\end{frame}

\end{document}